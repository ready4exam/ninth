<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Data Uploader Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    
    <script src="./js/config.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'], },
                    colors: {
                        'primary-blue': '#1a3e6a',
                        'accent-green': '#059669',
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 min-h-screen antialiased p-4">

    <div class="max-w-4xl mx-auto bg-white p-6 md:p-10 rounded-xl shadow-2xl border-t-8 border-primary-blue">
        <h1 class="text-3xl font-extrabold text-primary-blue mb-4">CSV Quiz Processor & Uploader</h1>
        <p class="text-gray-600 mb-6">
            **Step 1: Generate CSV.** Use your Gemini prompt to generate the 60 questions and copy the entire CSV output (including the header row).<br>
            **Step 2: Paste & Upload.** Paste the CSV below, specify the table, and click upload. **The script will now automatically clean up instances of 'nan' and remove LaTeX symbols.**
        </p>

        <div class="space-y-4 mb-6">
            <div>
                <label for="table-name" class="block text-sm font-medium text-gray-700">Target Supabase Table Name</label>
                <input type="text" id="table-name" value="force" class="mt-1 block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-accent-green focus:border-accent-green">
            </div>
            <div>
                <label for="csv-input" class="block text-sm font-medium text-gray-700">Paste Gemini CSV Output Here (Including Header)</label>
                <textarea id="csv-input" rows="10" placeholder="Paste your 60-question CSV output from Gemini here..." class="mt-1 block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-accent-green focus:border-accent-green"></textarea>
            </div>
        </div>

        <button id="automate-button" onclick="startAutomation()"
                class="w-full px-6 py-3 text-lg font-bold text-white bg-accent-green rounded-lg shadow-md hover:bg-green-700 transition duration-150">
            2. Parse CSV & Insert Data into Supabase
        </button>

        <div id="status-log" class="mt-8 space-y-2">
            <h2 class="text-xl font-semibold text-gray-700 mb-3">Process Log:</h2>
            <p id="log-initial" class="text-gray-500">Ready to start...</p>
        </div>
        
        <div id="config-error" class="hidden error-message mt-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative">
            **Configuration Error ðŸ›‘** Supabase credentials (`SUPABASE_URL`, `SUPABASE_ANON_KEY`) were not found. Please ensure the file **./js/config.js** exists and contains the correct definitions.
        </div>
    </div>

    <script>
        // --- Supabase and Database Constants ---
        // The column order must strictly match the CSV header.
        const DB_COLUMNS = [
            'difficulty', 'question_type', 'question_text', 
            'scenario_reason_text', 'option_a', 'option_b', 'option_c', 'option_d', 
            'correct_answer_key'
        ];
        
        // List of columns that need the LaTeX cleaning applied
        const LATEX_CLEANUP_COLUMNS = [
            'question_text', 'scenario_reason_text', 'option_a', 'option_b', 'option_c', 'option_d'
        ];

        let supabaseClient;
        let button;
        let log;

        // --- Utility Functions ---

        /**
         * Sanitizes a string by removing common LaTeX/KaTeX formatting.
         * @param {string | null} input The string to clean.
         * @returns {string | null} The cleaned string.
         */
        function cleanLatex(input) {
            if (input === null || typeof input !== 'string') return input;

            // 1. Remove common math environment delimiters ($, $$, \(, \), \[,\], {, })
            let cleaned = input.replace(/\$|\\\(|\\\)|\\\[|\\\]|{|}/g, '');

            // 2. Remove common text and vector commands (\text{}, \mathbf{}, \cdot, etc.)
            // This regex targets commands like \text{...} or \mathbf{...} and removes the command itself
            // but keeps the content inside the braces if possible.
            cleaned = cleaned.replace(/\\(text|mathbf|mathrm|unit|cdot|times|approx|sim|perp|parallel)\s*\{([^}]*)\}/g, '$2');
            
            // 3. Remove standalone commands without braces (\text, \mathbf, \rightarrow, \implies, etc.)
            cleaned = cleaned.replace(/\\(text|mathbf|rightarrow|implies|times|div|sum|int|sqrt|alpha|beta|gamma|delta|sigma|mu|rho|eta|tau|pi|deg)\s*/gi, ' ');
            
            // 4. Clean up remaining backslashes that might have been part of unsupported commands (e.g., \mathbf{i} -> i)
            cleaned = cleaned.replace(/\\/g, ''); 

            // 5. Clean up extra spaces introduced by replacements
            return cleaned.replace(/\s\s+/g, ' ').trim();
        }

        function init() {
            log = document.getElementById('status-log');
            button = document.getElementById('automate-button');
            
            // Check the globally exposed variables, which should be loaded from ./js/config.js
            if (typeof window.SUPABASE_URL === 'undefined' || typeof window.SUPABASE_ANON_KEY === 'undefined' || window.SUPABASE_URL === null) {
                 document.getElementById('log-initial').textContent = "Configuration required...";
                 document.getElementById('config-error').classList.remove('hidden');
                 button.disabled = true;
                 return;
            }
            
            document.getElementById('log-initial').textContent = "Initializing environment...";
            
            // Initialize Supabase Client
            try {
                supabaseClient = supabase.createClient(
                    window.SUPABASE_URL,
                    window.SUPABASE_ANON_KEY
                );
                logMessage('Supabase client initialized successfully. Ready to process CSV.', 'success');
            } catch (e) {
                logMessage(`Error initializing Supabase client: ${e.message}`, 'error');
                button.disabled = true;
            }
        }

        function logMessage(message, type = 'info') {
            const p = document.createElement('p');
            p.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`; // Use innerHTML for bolding
            p.className = 'p-2 rounded';
            
            if (type === 'info') p.classList.add('bg-gray-100', 'text-gray-700');
            if (type === 'success') p.classList.add('bg-green-100', 'text-accent-green', 'font-semibold');
            if (type === 'error') p.classList.add('bg-red-100', 'text-red-700', 'font-semibold');
            if (type === 'warning') p.classList.add('bg-yellow-100', 'text-yellow-700');

            // Insert new message at the top of the log
            const logContainer = document.getElementById('status-log');
            const firstLogEntry = logContainer.querySelector('h2').nextElementSibling;
            logContainer.insertBefore(p, firstLogEntry);
        }

        function setButtonState(disabled, text) {
            button.disabled = disabled;
            button.textContent = text;
        }
        
        // --- Robust CSV Parsing Logic ---

        // Regex to split by comma while respecting quoted fields.
        const CSV_REGEX = /(?!\s*$",)(?!\s*$)\s*(?:(?:"((?:[^"]|"")*)")|([^",]*))\s*(?:,|$)/g;

        function parseCSV(csvString) {
            logMessage('Parsing CSV data...');
            
            // --- AGGRESSIVE PRE-PROCESSING FIX FOR 'nan' ISSUE ---
            let cleanString = csvString.trim().replace(/^\uFEFF/, '');
            // This replaces all standalone, unquoted "nan" or "NaN" strings with an empty string/empty field
            cleanString = cleanString.replace(/,nan,|,NaN,/, ",,"); 
            cleanString = cleanString.replace(/,nan\n|,NaN\n/, ",\n"); 
            
            const lines = cleanString.split('\n');
            
            if (lines.length < 2) {
                throw new Error("CSV input must contain at least a header row and one data row.");
            }
            
            // --- 1. Header Check ---
            const headerLine = lines[0];
            const header = headerLine.split(',').map(h => h.trim().replace(/['"]+/g, '').toLowerCase());
            const expectedHeader = DB_COLUMNS.map(col => col.toLowerCase()); 
            
            const headerMatch = expectedHeader.every((expectedCol, i) => 
                header[i] && header[i].includes(expectedCol)
            );

            if (!headerMatch) {
                logMessage(`Error: Header mismatch. Please ensure the header is: ${DB_COLUMNS.join(', ')}`, 'error');
                logMessage(`Found header columns: ${header.join(', ')}`, 'error');
                throw new Error("CSV Header mismatch. Check the log for required vs. found columns.");
            }
            
            // --- 2. Data Parsing and Cleaning ---
            const data = [];
            const timestampCol = 'created_at';
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue;

                const fields = line.match(CSV_REGEX);

                if (!fields || fields.length !== DB_COLUMNS.length) {
                    logMessage(`Skipping row ${i + 1} due to incorrect column count (${fields ? fields.length : 0} found, expected ${DB_COLUMNS.length}). Line data: ${line.substring(0, 50)}...`, 'warning');
                    continue;
                }

                let rowData = {};
                rowData[timestampCol] = new Date().toISOString();

                for (let j = 0; j < DB_COLUMNS.length; j++) {
                    const colName = DB_COLUMNS[j];
                    const field = fields[j];

                    let value = field.match(/"((?:[^"]|"")*)"|([^",]*)/)?.[1] || field.match(/"((?:[^"]|"")*)"|([^",]*)/)?.[2];
                    
                    value = value ? value.trim().replace(/^"|"$/g, '').replace(/""/g, '"') : "";
                    
                    // Explicitly handle empty strings or 'null' as null
                    if (value === '' || value.toLowerCase() === 'null' || value.toLowerCase() === 'nan') {
                        value = null;
                    }

                    // *** NEW: Apply LaTeX cleaning to relevant columns ***
                    if (LATEX_CLEANUP_COLUMNS.includes(colName) && value !== null) {
                        value = cleanLatex(value);
                    }

                    rowData[colName] = value;
                }
                
                data.push(rowData);
            }
            
            if (data.length === 0) {
                 throw new Error("Failed to parse any valid data rows. Check the CSV format for structural issues.");
            }

            logMessage(`Successfully parsed **${data.length}** records from CSV.`, 'success');
            return data;
        }


        // --- Supabase Insertion Logic (Unchanged) ---

        async function insertDataIntoSupabase(tableName, data) {
            logMessage(`Attempting to insert ${data.length} records into table **${tableName}**...`);
            
            const { data: insertedData, error } = await supabaseClient
                .from(tableName)
                .insert(data)
                .select(); 

            if (error) {
                if (error.message.includes("violates row-level security policy") || error.message.includes("permission denied")) {
                     throw new Error(`Supabase insertion error: Permission Denied. Check that **Row Level Security (RLS)** policy includes the 'anon' role for INSERTs on table '${tableName}'.`);
                }
                throw new Error(`Supabase insertion error: ${error.message}`);
            }

            return insertedData;
        }

        // --- Main Automation Workflow ---

        async function startAutomation() {
            if (!supabaseClient) {
                logMessage('Initialization failed. Please check configuration and try again.', 'error');
                return;
            }
            
            const tableName = document.getElementById('table-name').value.trim();
            const csvInput = document.getElementById('csv-input').value.trim();
            
            if (!tableName) {
                logMessage('Table Name is required.', 'error');
                return;
            }
            if (!csvInput) {
                logMessage('Please paste the CSV data into the text area.', 'error');
                return;
            }

            setButtonState(true, 'Processing: Parsing CSV...');
            
            try {
                // 1. Parse CSV Data
                const quizData = parseCSV(csvInput);
                
                if (!quizData || quizData.length === 0) {
                    throw new Error("No valid data rows were parsed from the CSV.");
                }
                logMessage(`Content Parsed: Ready to insert **${quizData.length}** records.`, 'success');

                // 2. Insert Data into Supabase
                setButtonState(true, 'Processing: Inserting into Supabase...');
                const insertedRecords = await insertDataIntoSupabase(tableName, quizData);
                
                // 3. Complete
                logMessage(`2. Data successfully inserted! **${insertedRecords.length}** records added to table **${tableName}**.`, 'success');
                logMessage('Automation Complete. You can now process another CSV.', 'success');
                setButtonState(false, 'Upload Another CSV');

            } catch (error) {
                logMessage(`Automation Failed: ${error.message}`, 'error');
                setButtonState(false, 'Error. Check Log and Try Again.');
            }
        }
        
        document.addEventListener('DOMContentLoaded', init);
        
        window.startAutomation = startAutomation;
    </script>
</body>
</html>
```eof

### Key Fixes in This Version

1.  **`cleanLatex` Function:** I created a dedicated `cleanLatex` function to handle the bulk of the cleanup outside the main parsing loop.
2.  **Bracket/Delimiter Removal:** It targets and removes common math delimiters like `$`, `\(` `\)`, `[` `]`, and curly braces `{}`.
3.  **Command Replacement:** It uses regular expressions to find commands like `\text{ N}` and `\mathbf{i}` and replaces the command with the content inside its braces (e.g., `\text{ N}` becomes ` N`).
4.  **Final Backslash Cleanup:** It removes any remaining backslashes (`\`) that might have been part of unsupported or standalone commands.

This should finally give you clean, plain-text data for all your quiz fields. Give this version a try!
